<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>A Turn of Phrase</title>
    <link>http://blog.nickklauer.info/</link>
    <description>Recent content on A Turn of Phrase</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 15 Oct 2015 20:02:18 -0500</lastBuildDate>
    <atom:link href="http://blog.nickklauer.info/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>keystores and certificate expiration</title>
      <link>http://blog.nickklauer.info/2015/keystores-and-certificate-expiration/</link>
      <pubDate>Thu, 15 Oct 2015 20:02:18 -0500</pubDate>
      
      <guid>http://blog.nickklauer.info/2015/keystores-and-certificate-expiration/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve seldom had to work with the Java Keystore, but as more and more sites start
using SSL, it&amp;rsquo;s grown more important to ensure that certificates stored on your
side don&amp;rsquo;t arbitrarily expire.  This is especially important if you&amp;rsquo;re not
simply relying or verifying intermediate and root certificates.  A self-signed
server certificate is oftentimes &lt;em&gt;easy enough&lt;/em&gt; to do for some applications, and
that expiration can come quicker than you anticipate.&lt;/p&gt;

&lt;p&gt;In this section, I&amp;rsquo;ll demonstrate a little bit about how you can get at the
certificate store within the relatively standard JKS-format of the Java
Cryptography Keystore.  Other stores may not work this way, or may require
a different set of processes.&lt;/p&gt;

&lt;p&gt;Side Note: I have to give credit where credit is due, and &lt;a href=&#34;http://stackoverflow.com/a/10986535/7008&#34;&gt;this StackOverflow
answer&lt;/a&gt;
provided a great starting point for getting things going.  It was essentially
the foundation for what you&amp;rsquo;ll see in this post.&lt;/p&gt;

&lt;h1 id=&#34;parsing-the-keystore:ea83c6f13264b77e32b6387eb48f3ca8&#34;&gt;Parsing the Keystore&lt;/h1&gt;

&lt;p&gt;To make this easy, I generally use the following libraries in most of my
projects:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/google/guava&#34;&gt;Google Guava&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.joda.org/joda-time/&#34;&gt;Joda Time&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Of course, if you&amp;rsquo;re lucky enough to use Java 8, we&amp;rsquo;d be using
&lt;a href=&#34;http://www.oracle.com/technetwork/articles/java/jf14-date-time-2125367.html&#34;&gt;Java 8&amp;rsquo;s Date and Time&lt;/a&gt;
library.  But, for a vast majority of users, we&amp;rsquo;re stuck with 7 or less.
Ah, c&amp;rsquo;est la vie.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Reading the Keystore is actually a pretty straight-forward process:&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&#34;language-java&#34;&gt;
// import a ton of stuff
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import org.joda.time.DateTime;
import org.joda.time.Days;

import java.io.FileInputStream;
import java.io.IOException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableEntryException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.*;

// ... more code, some method somewhere

KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
char[] pass = &#34;changeit&#34;; // or whatever

java.io.InputStream fis = null;
try {
    fis = Reader.class.getClassLoader().getResourceAsStream(file_path);
    ks.load(fis, pass);

    // Get Certificate listing

} finally {
    if (fis != null) {
        fis.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&#34;traversing-certificates-and-aliases:ea83c6f13264b77e32b6387eb48f3ca8&#34;&gt;Traversing Certificates and Aliases&lt;/h1&gt;

&lt;p&gt;From this point, we&amp;rsquo;re able to read in and claim &lt;strong&gt;success&lt;/strong&gt;! Nah, not really.
What do you want to do with this?  Well, in this case, our KeyStore will have
a lot of various certificates and trusts in it.  For our use, we simply want to
validate the ones that are going to expire.&lt;/p&gt;

&lt;p&gt;With each certificate that we have, there are likely 1 or more other
certificates in a &lt;a href=&#34;https://support.dnsimple.com/articles/what-is-ssl-certificate-chain/&#34;&gt;&lt;strong&gt;certificate chain&lt;/strong&gt;&lt;/a&gt;.
We aren&amp;rsquo;t simply going to find expired server certificates (although that&amp;rsquo;s
laudable in and of itself), but we want to be sure we aren&amp;rsquo;t going to suffer the
fate of thinking &amp;ldquo;well, our server cert passed, but this whole tree of servers&amp;rsquo;
intermediate certificates expired&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&#34;language-java&#34;&gt;
private static Map&lt;String, List&lt;Certificate&gt;&gt; getCertMap(KeyStore ks) throws KeyStoreException {
    Map&lt;String, List&lt;Certificate&gt;&gt; cert_map = Maps.newHashMap(); // Good &#39;ol Guava
    // Each KeyStore can return an &#34;Enumeration&#34; of aliases
    Enumeration&lt;String&gt; aliases = ks.aliases();
    while (aliases.hasMoreElements()) {
        String alias = aliases.nextElement();
        Certificate[] certs = ks.getCertificateChain(alias);
        // It&#39;s not a guarantee that you&#39;ll have ANY certificates
        if (certs != null &amp;&amp; certs.length &gt; 0) {
            cert_map.put(alias, Lists.newArrayList(certs));
        } else {
            Certificate cert = ks.getCertificate(alias);
            cert_map.put(alias, Lists.newArrayList(cert));
        }
    }
    return cert_map;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h1 id=&#34;filtering:ea83c6f13264b77e32b6387eb48f3ca8&#34;&gt;Filtering&lt;/h1&gt;

&lt;p&gt;Another assumption being made here is that if you have a certificate that&amp;rsquo;s
going to expire, it&amp;rsquo;s most likely an &lt;strong&gt;X.509&lt;/strong&gt; certificate, and so we only need
to be concerned with a subset of certificates.&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&#34;language-java&#34;&gt;
    private static Map&lt;String, List&lt;X509Certificate&gt;&gt; filterX509Certs(Map&lt;String, List&lt;Certificate&gt;&gt; cert_map) {
        Map&lt;String, List&lt;X509Certificate&gt;&gt; x509_map = Maps.newHashMap();
        for (Map.Entry&lt;String, List&lt;Certificate&gt;&gt; c : cert_map.entrySet()) {
            List&lt;X509Certificate&gt; certs = Lists.newArrayListWithCapacity(c.getValue().size());
            for (Certificate cert : c.getValue()) {
                // This is where the magic happens...
                if (cert.getType().equals(&#34;X.509&#34;)) {
                    // cast the type to X509Certificate
                    certs.add((X509Certificate) cert);
                }
            }
            x509_map.put(c.getKey(), certs);
        }
        return x509_map;
    }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;It took a lot longer to figure out that this one little line&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&#34;language-java&#34;&gt;if (cert.getType().equals(&#34;X.509&#34;)) {
&lt;/code&gt;
&lt;/pre&gt;
is where you figure out the type.

# Finding by Date

Now that we have a mapped-listing of X.509 certificates and their chains mapped
to an alias, we can iterate over them to find by date:

&lt;pre&gt;
&lt;code class=&#34;language-java&#34;&gt;
private static List&lt;X509Certificate&gt; filterCertificates(List&lt;X509Certificate&gt; certs, int days_threshold) {
    List&lt;X509Certificate&gt; filtered = Lists.newArrayList();
    for (X509Certificate cert : certs) {
        DateTime expiration_date = new DateTime(cert.getNotAfter());
        int days_to_expiration = Days.daysBetween(DateTime.now(), expiration_date.getDays();
        if (days_to_expiration &lt; days_threshold) {
            filtered.add(cert);
        }
    }
    return filtered;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Here, we&amp;rsquo;re simply making use of the excellent &lt;a href=&#34;http://www.joda.org/joda-time/quickstart.html&#34;&gt;Joda DateTime&lt;/a&gt;
to parse the &lt;code&gt;java.util.Date&lt;/code&gt; object and compute the days between the curren
time and the expiration date.  I&amp;rsquo;d rather not worry about leap years, other
calendar types, etc., when computing things, so let&amp;rsquo;s just let a great library
do that for us.&lt;/p&gt;

&lt;h1 id=&#34;summary:ea83c6f13264b77e32b6387eb48f3ca8&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;I hope this overview of how to parse and compute expiration dates on
certificates in your Keystore can be of some use.  It&amp;rsquo;s not hard, but half the
battle is figuring out &lt;strong&gt;what&lt;/strong&gt; you need to know before you do it.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>