<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2016s on A Blog</title>
    <link>http://blog.nickklauer.info/2016/</link>
    <description>Recent content in 2016s on A Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 27 Jun 2016 18:52:47 -0500</lastBuildDate>
    <atom:link href="http://blog.nickklauer.info/2016/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>More Thoughts on Go</title>
      <link>http://blog.nickklauer.info/2016/more_thoughts_on_go/</link>
      <pubDate>Mon, 27 Jun 2016 18:52:47 -0500</pubDate>
      
      <guid>http://blog.nickklauer.info/2016/more_thoughts_on_go/</guid>
      <description>

&lt;h1 id=&#34;a-meh-language-with-a-stellar-platform&#34;&gt;A &amp;lsquo;meh&amp;rsquo; language, with a stellar platform&lt;/h1&gt;

&lt;p&gt;I keep finding myself toying with Go, thinking of throwing together projects
with it.  It&amp;rsquo;s hard to really appreciate it until you take it&amp;rsquo;s entire framework
together as a full set.  In much the same way, I appreciate and enjoy coding in
Java.  Not so much for Java&amp;rsquo;s language features (I&amp;rsquo;d hardly call
Java-the-language cutting edge), but more for the entire platform and community
around it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JVM GC Log Parsing</title>
      <link>http://blog.nickklauer.info/2016/jvmgc-log-parsing/</link>
      <pubDate>Sun, 13 Mar 2016 20:00:00 -0500</pubDate>
      
      <guid>http://blog.nickklauer.info/2016/jvmgc-log-parsing/</guid>
      <description>

&lt;p&gt;Along the same lines as my &lt;a href=&#34;../netgearlogs&#34;&gt;previous post&lt;/a&gt;, I had a need to
analyze a set of JVM Garbage Collector logs for event types.  Consider a log
entry like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2016-02-11T23:39:01.847-0600: 6062789.760: [GC2016-02-11T23:39:01.848-0600: 6062789.761: [ParNew
Desired survivor size 178946048 bytes, new threshold 15 (max 15)
- age   1:    3565648 bytes,    3565648 total
- age   2:     278800 bytes,    3844448 total
- age   3:    1203288 bytes,    5047736 total
- age   4:      33184 bytes,    5080920 total
- age   5:    1717432 bytes,    6798352 total
- age   6:    1673032 bytes,    8471384 total
- age   7:     792920 bytes,    9264304 total
- age   8:     275424 bytes,    9539728 total
- age   9:     262384 bytes,    9802112 total
- age  10:     517584 bytes,   10319696 total
- age  11:       4576 bytes,   10324272 total
- age  12:     444104 bytes,   10768376 total
- age  13:      32080 bytes,   10800456 total
- age  14:     512392 bytes,   11312848 total
- age  15:     359904 bytes,   11672752 total
: 1416735K-&amp;gt;15751K(1747648K), 0.0379220 secs] 4798752K-&amp;gt;3399739K(8039104K), 0.0384330 secs] [Times: user=0.00 sys=0.32, real=0.04 secs]
Heap
 par new generation   total 1747648K, used 1145132K [0x00000005a0000000, 0x0000000620000000, 0x0000000620000000)
  eden space 1398144K,  80% used [0x00000005a0000000, 0x00000005e4ee9178, 0x00000005f5560000)
  from space 349504K,   4% used [0x000000060aab0000, 0x000000060ba11eb8, 0x0000000620000000)
  to   space 349504K,   0% used [0x00000005f5560000, 0x00000005f5560000, 0x000000060aab0000)
 concurrent mark-sweep generation total 6291456K, used 3383987K [0x0000000620000000, 0x00000007a0000000, 0x00000007a0000000)
 concurrent-mark-sweep perm gen total 941872K, used 553029K [0x00000007a0000000, 0x00000007d97cc000, 0x0000000800000000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This kind of log entry is far from simple to understand.  I could go about
hand-writing another parser, but I don&amp;rsquo;t know if it would be anywhere near the
same level of complexity.  In fact, for the most part, all I really wanted to
know was the following:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2016-02-11T23:39:01.847-0600&lt;/strong&gt;: &lt;strong&gt;6062789.760&lt;/strong&gt;: [GC2016-02-11T23:39:01.848-0600: 6062789.761: [&lt;strong&gt;ParNew&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Trying to parse much else from the get-go seemed a bit much, and there&amp;rsquo;s
a &lt;strong&gt;lot&lt;/strong&gt; of output that I&amp;rsquo;d have to skip around just to find these entries.&lt;/p&gt;

&lt;p&gt;Not knowing where to look, I threw a question out to one of my favorite go-to
tools for parsing JVM logs: &lt;a href=&#34;https://github.com/chewiebug/GCViewer&#34;&gt;GCViewer&lt;/a&gt;.
There must be &lt;em&gt;something&lt;/em&gt; that you can use in there to parse out a log entry.
Reaching out to the developer in an issue, I was able to get pointed in the
&lt;a href=&#34;https://github.com/chewiebug/GCViewer/issues/164#issuecomment-195405552&#34;&gt;right direction&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hi Nick,&lt;/p&gt;

&lt;p&gt;I see two options to get the information for your alerting:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;use the command-line interface of GCViewer to generate a CSV file
 containing a lot of information (java -jar gcviewer-1.3x.jar gc.log
 summary.csv) -&amp;gt; parse the csv file and extract the information&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java/com/tagtraum/perf/gcviewer/imp/DataReaderFacade.java&lt;/code&gt; and use
 the resulting GCModel to extract the information you are looking for for
 the alerts.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Best regards,
JÃ¶rg&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I looked at #2, and found that this makes parsing a log file relatively
painless, and gives you a lot in the way of structural analysis of the logs
themselves.&lt;/p&gt;

&lt;h2 id=&#34;using-gcviewer-for-log-parsing-as-an-api&#34;&gt;Using GCViewer for Log Parsing as an API&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package klauern;

import com.tagtraum.perf.gcviewer.imp.DataReaderException;
import com.tagtraum.perf.gcviewer.imp.DataReaderFacade;
import com.tagtraum.perf.gcviewer.model.*;

import java.util.Iterator;

public class EventParser {

    public static void main(String[] args) throws DataReaderException {
        System.out.println(&amp;quot;Getting DataReader facade&amp;quot;);
        DataReaderFacade drf = new DataReaderFacade();
        System.out.println(&amp;quot;Loading model&amp;quot;);
        GCModel model = drf.loadModel(new GCResource(&amp;quot;src/test/resources/gc-log.current&amp;quot;));
        System.out.println(&amp;quot;Model Loaded&amp;quot;);

        System.out.println(&amp;quot;List Full GC Events:\n&amp;quot;);
        Iterator&amp;lt;GCEvent&amp;gt; full_gcs = model.getFullGCEvents();
        while (full_gcs.hasNext()) {
            GCEvent event = full_gcs.next();
            System.out.println(&amp;quot;Date: &amp;quot; + event.getDatestamp() + &amp;quot; Pause: &amp;quot; + event.getPause());
        }
        System.out.println(&amp;quot;List stop the world events:\n&amp;quot;);
        Iterator&amp;lt;AbstractGCEvent&amp;lt;?&amp;gt;&amp;gt; stw_events = model.getStopTheWorldEvents();
        while (stw_events.hasNext()) {
            AbstractGCEvent&amp;lt;?&amp;gt; event = stw_events.next();
            System.out.println(&amp;quot;Type: &amp;quot; + event.getTypeAsString() + &amp;quot; Date: &amp;quot; + event.getDatestamp() + &amp;quot; Pause: &amp;quot; + event.getPause());
        }

        System.out.println(&amp;quot;List CMS GC events&amp;quot;);
        Iterator&amp;lt;ConcurrentGCEvent&amp;gt; cms_gc_events = model.getConcurrentGCEvents();
        while (cms_gc_events.hasNext()) {
            ConcurrentGCEvent event = cms_gc_events.next();
            System.out.println(&amp;quot;Date: &amp;quot; + event.getDatestamp() + &amp;quot; Pause: &amp;quot; + event.getPause());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is just so simple, you have a lot at your fingertips.  Running this little
sample code on one of my example JVM logs produces the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Getting datareader facade
Loading model
Model Loaded
List Full GC Events:

List stop the world events:

Type: GC; ParNew Date: 2016-02-11T10:46:54.607-06:00 Pause: 0.058497
Type: GC; ParNew Date: 2016-02-11T10:47:34.438-06:00 Pause: 0.060133
Type: GC; ParNew Date: 2016-02-11T10:47:54.505-06:00 Pause: 0.057339
Type: GC; ParNew Date: 2016-02-11T10:47:56.742-06:00 Pause: 0.042955
.... # continues for a while
List CMS GC events
Date: 2016-02-11T15:04:21.175-06:00 Pause: 0.0
Date: 2016-02-11T15:04:23.193-06:00 Pause: 2.018
Date: 2016-02-11T15:04:23.193-06:00 Pause: 0.0
Date: 2016-02-11T15:04:23.231-06:00 Pause: 0.036
Date: 2016-02-11T15:04:23.231-06:00 Pause: 0.0
Date: 2016-02-11T15:04:28.254-06:00 Pause: 4.912
Date: 2016-02-11T15:04:29.004-06:00 Pause: 0.0
Date: 2016-02-11T15:04:34.463-06:00 Pause: 3.232
Date: 2016-02-11T15:04:34.463-06:00 Pause: 0.0
Date: 2016-02-11T15:04:34.491-06:00 Pause: 0.028
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From this point, I can really pull together some good statistics on frequency,
rate of growth, high-activity, and create those smell tests that you wish you
knew before something blew up in your face.  In my work experience, it&amp;rsquo;s not
often that people do enough testing with production-sized loads, or if they do,
they underestimate what those load look like.  It&amp;rsquo;s the worst possible scenario
to have poor performance only in your production environment, as it is
a possible indicator that these kind of GC-related events were present in your
testing but were completely missed or avoided because they weren&amp;rsquo;t visible.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Playing with NetGear Router Logs</title>
      <link>http://blog.nickklauer.info/2016/netgearlogs/</link>
      <pubDate>Sun, 13 Mar 2016 11:26:34 -0500</pubDate>
      
      <guid>http://blog.nickklauer.info/2016/netgearlogs/</guid>
      <description>

&lt;p&gt;I was recently toying around on my router and noticed that I can send myself
a set of logs related to activity going on.  Considering this an interesting
set of diagnostics, I thought it would be fun to create some way to parse these
log entries and save them in some format.  In addition, as I am also always
trying out new languages, the current language du jour is
&lt;a href=&#34;https://golang.org&#34;&gt;Golang&lt;/a&gt;, so it seems like a reasonably interesting problem
to solve in a library.&lt;/p&gt;

&lt;h2 id=&#34;example-netgear-log-entries&#34;&gt;Example NetGear Log Entries&lt;/h2&gt;

&lt;p&gt;Parsing a log seems like a fun diversion, and looking at the NetGear log format,
it seems apparent that there was little formality in how they even logged what
happened.  There&amp;rsquo;s &lt;strong&gt;some&lt;/strong&gt; structure to it, but it&amp;rsquo;s kinda messy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[DoS Attack: ACK Scan] from source: 195.179.119.177, port 80, Monday, February 22, 2016 04:42:22
[Internet connected] IP address: 127.0.0.1, Monday, February 22, 2016 09:02:59
[DHCP IP: 192.168.1.11] to MAC address ff:ff:ff:ff:ff:ff, Monday, February 22, 2016 06:15:56
[UPnP set event: del_nat_rule] from source 192.168.1.8, Saturday, February 20, 2016 19:27:21
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that while it seems like everything within the square braces (&lt;code&gt;[]&lt;/code&gt;)
is simple, things like &lt;code&gt;DHCP IP: 192.168.1.11&lt;/code&gt; seem like a mixture of a rule
type and a dynamic piece of data.  Parsing this isn&amp;rsquo;t like parsing a regular
format, or at least, it has enough special rules that will make creating
a parser a bit more work.&lt;/p&gt;

&lt;h2 id=&#34;parsing-logs&#34;&gt;Parsing Logs&lt;/h2&gt;

&lt;p&gt;I struck out to solve this in a couple ways.  My first attempt was a very simple
attempt to brute-force the log by &lt;code&gt;switch&lt;/code&gt;&amp;lsquo;ing on a prefix, using some kind
of parsing for each type of log entry.  You can find example code of this on my
GitHub project here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/klauern/go-netgearlogs/blob/master/netgear.go&#34;&gt;github.com/klauern/go-netgearlogs/netgear.go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t particularly like the repetitive nature of it, but I wonder whether this
isn&amp;rsquo;t just &amp;lsquo;acceptable code duplication&amp;rsquo; due to the nature of Go not allowing
much in the way of abstraction.  That said, this works, and it throws everything
I have given it into my generic &lt;code&gt;NetGear&lt;/code&gt; struct type.  Yay for progress.&lt;/p&gt;

&lt;h2 id=&#34;go-s-parsing-strategies&#34;&gt;Go&amp;rsquo;s Parsing Strategies&lt;/h2&gt;

&lt;p&gt;After throwing together the above example, I started doing a bit more digging
and trying to determine if there was a &amp;ldquo;Go Way&amp;rdquo; to do things.  This is where
I stumbled on an article I was really excited about reading on the topic:
&lt;a href=&#34;https://blog.gopheracademy.com/advent-2014/parsers-lexers/&#34;&gt;Handwritten Parsers &amp;amp; Lexers in Go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Using the above blog as a guide, I struck out to create another format of the
parsing, to see if it would turn out to be simpler and/or more flexible. Currently,
I have some files that are still in-progress, but feel MUCH more like
a real parsing attempt for my problem.  I took a lot of inspiration
(&lt;em&gt;cough&lt;/em&gt; copying &lt;em&gt;cough&lt;/em&gt;)  from this article, and the current result can be
found in the source below:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/klauern/go-netgearlogs/blob/master/token.go&#34;&gt;github.com/klauern/go-netgearlogs/token.go&lt;/a&gt; (my list of tokens for a NetGear Log)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/klauern/go-netgearlogs/blob/master/scanner.go&#34;&gt;github.com/klauern/go-netgearlogs/scanner.go&lt;/a&gt; (scanner for tokenizing the input into something above)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/klauern/go-netgearlogs/blob/master/parser.go&#34;&gt;github.com/klauern/go-netgearlogs/parser.go&lt;/a&gt; (parser for converting those tokens into something tangible)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is still a work-in-progress, but I highly recommend the blog post above if
you&amp;rsquo;re curious on writing your own parser.  I also recommend finding something
to write a parser for.  It really gives you a window into the world of text
processing, programming language design, etc., and I walked away with a lot of
knowledge on parsing that I did not have before.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>