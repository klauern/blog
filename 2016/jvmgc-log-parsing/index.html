<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.17-DEV" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/ir_black.min.css">

<script src="js/highlight.pack.js"</script>
<script>hljs.initHighlightingOnLoad();</script>
<link href="http://fonts.googleapis.com/css?family=Roboto:400,700" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="/css/normalize.css">
<link rel="stylesheet" href="/css/skeleton.css">
<link rel="stylesheet" href="/css/custom.css">
<link rel="alternate" href="/index.xml" type="application/rss+xml" title="A Blog">
<title>JVM GC Log Parsing - A Blog</title>
</head>
<body>

<div class="container">

	<header role="banner">
		<div class="header-logo">
			<a href="/"><img src="https://s.gravatar.com/avatar/76c55292df5e9df9042eaf89ac35954b?s=80" width="60" height="60"></a>
		</div>
		
	</header>


	<main role="main">
		<article itemscope itemtype="http://schema.org/BlogPosting">
			<h1 class="entry-title" itemprop="headline">JVM GC Log Parsing</h1>
			<span class="entry-meta"><time itemprop="datePublished" datetime="2016-03-13">March 13, 2016</time></span>
			<section itemprop="entry-text">
				

<p>Along the same lines as my <a href="../netgearlogs">previous post</a>, I had a need to
analyze a set of JVM Garbage Collector logs for event types.  Consider a log
entry like the following:</p>

<pre><code>2016-02-11T23:39:01.847-0600: 6062789.760: [GC2016-02-11T23:39:01.848-0600: 6062789.761: [ParNew
Desired survivor size 178946048 bytes, new threshold 15 (max 15)
- age   1:    3565648 bytes,    3565648 total
- age   2:     278800 bytes,    3844448 total
- age   3:    1203288 bytes,    5047736 total
- age   4:      33184 bytes,    5080920 total
- age   5:    1717432 bytes,    6798352 total
- age   6:    1673032 bytes,    8471384 total
- age   7:     792920 bytes,    9264304 total
- age   8:     275424 bytes,    9539728 total
- age   9:     262384 bytes,    9802112 total
- age  10:     517584 bytes,   10319696 total
- age  11:       4576 bytes,   10324272 total
- age  12:     444104 bytes,   10768376 total
- age  13:      32080 bytes,   10800456 total
- age  14:     512392 bytes,   11312848 total
- age  15:     359904 bytes,   11672752 total
: 1416735K-&gt;15751K(1747648K), 0.0379220 secs] 4798752K-&gt;3399739K(8039104K), 0.0384330 secs] [Times: user=0.00 sys=0.32, real=0.04 secs]
Heap
 par new generation   total 1747648K, used 1145132K [0x00000005a0000000, 0x0000000620000000, 0x0000000620000000)
  eden space 1398144K,  80% used [0x00000005a0000000, 0x00000005e4ee9178, 0x00000005f5560000)
  from space 349504K,   4% used [0x000000060aab0000, 0x000000060ba11eb8, 0x0000000620000000)
  to   space 349504K,   0% used [0x00000005f5560000, 0x00000005f5560000, 0x000000060aab0000)
 concurrent mark-sweep generation total 6291456K, used 3383987K [0x0000000620000000, 0x00000007a0000000, 0x00000007a0000000)
 concurrent-mark-sweep perm gen total 941872K, used 553029K [0x00000007a0000000, 0x00000007d97cc000, 0x0000000800000000)
</code></pre>

<p>This kind of log entry is far from simple to understand.  I could go about
hand-writing another parser, but I don&rsquo;t know if it would be anywhere near the
same level of complexity.  In fact, for the most part, all I really wanted to
know was the following:</p>

<p><strong>2016-02-11T23:39:01.847-0600</strong>: <strong>6062789.760</strong>: [GC2016-02-11T23:39:01.848-0600: 6062789.761: [<strong>ParNew</strong></p>

<p>Trying to parse much else from the get-go seemed a bit much, and there&rsquo;s
a <strong>lot</strong> of output that I&rsquo;d have to skip around just to find these entries.</p>

<p>Not knowing where to look, I threw a question out to one of my favorite go-to
tools for parsing JVM logs: <a href="https://github.com/chewiebug/GCViewer">GCViewer</a>.
There must be <em>something</em> that you can use in there to parse out a log entry.
Reaching out to the developer in an issue, I was able to get pointed in the
<a href="https://github.com/chewiebug/GCViewer/issues/164#issuecomment-195405552">right direction</a>:</p>

<blockquote>
<p>Hi Nick,</p>

<p>I see two options to get the information for your alerting:</p>

<ol>
<li>use the command-line interface of GCViewer to generate a CSV file
 containing a lot of information (java -jar gcviewer-1.3x.jar gc.log
 summary.csv) -&gt; parse the csv file and extract the information</li>
<li><code>java/com/tagtraum/perf/gcviewer/imp/DataReaderFacade.java</code> and use
 the resulting GCModel to extract the information you are looking for for
 the alerts.</li>
</ol>

<p>Best regards,
JÃ¶rg</p>
</blockquote>

<p>I looked at #2, and found that this makes parsing a log file relatively
painless, and gives you a lot in the way of structural analysis of the logs
themselves.</p>

<h2 id="using-gcviewer-for-log-parsing-as-an-api">Using GCViewer for Log Parsing as an API</h2>

<pre><code class="language-java">package klauern;

import com.tagtraum.perf.gcviewer.imp.DataReaderException;
import com.tagtraum.perf.gcviewer.imp.DataReaderFacade;
import com.tagtraum.perf.gcviewer.model.*;

import java.util.Iterator;

public class EventParser {

    public static void main(String[] args) throws DataReaderException {
        System.out.println(&quot;Getting DataReader facade&quot;);
        DataReaderFacade drf = new DataReaderFacade();
        System.out.println(&quot;Loading model&quot;);
        GCModel model = drf.loadModel(new GCResource(&quot;src/test/resources/gc-log.current&quot;));
        System.out.println(&quot;Model Loaded&quot;);

        System.out.println(&quot;List Full GC Events:\n&quot;);
        Iterator&lt;GCEvent&gt; full_gcs = model.getFullGCEvents();
        while (full_gcs.hasNext()) {
            GCEvent event = full_gcs.next();
            System.out.println(&quot;Date: &quot; + event.getDatestamp() + &quot; Pause: &quot; + event.getPause());
        }
        System.out.println(&quot;List stop the world events:\n&quot;);
        Iterator&lt;AbstractGCEvent&lt;?&gt;&gt; stw_events = model.getStopTheWorldEvents();
        while (stw_events.hasNext()) {
            AbstractGCEvent&lt;?&gt; event = stw_events.next();
            System.out.println(&quot;Type: &quot; + event.getTypeAsString() + &quot; Date: &quot; + event.getDatestamp() + &quot; Pause: &quot; + event.getPause());
        }

        System.out.println(&quot;List CMS GC events&quot;);
        Iterator&lt;ConcurrentGCEvent&gt; cms_gc_events = model.getConcurrentGCEvents();
        while (cms_gc_events.hasNext()) {
            ConcurrentGCEvent event = cms_gc_events.next();
            System.out.println(&quot;Date: &quot; + event.getDatestamp() + &quot; Pause: &quot; + event.getPause());
        }
    }
}
</code></pre>

<p>This is just so simple, you have a lot at your fingertips.  Running this little
sample code on one of my example JVM logs produces the following:</p>

<pre><code>Getting datareader facade
Loading model
Model Loaded
List Full GC Events:

List stop the world events:

Type: GC; ParNew Date: 2016-02-11T10:46:54.607-06:00 Pause: 0.058497
Type: GC; ParNew Date: 2016-02-11T10:47:34.438-06:00 Pause: 0.060133
Type: GC; ParNew Date: 2016-02-11T10:47:54.505-06:00 Pause: 0.057339
Type: GC; ParNew Date: 2016-02-11T10:47:56.742-06:00 Pause: 0.042955
.... # continues for a while
List CMS GC events
Date: 2016-02-11T15:04:21.175-06:00 Pause: 0.0
Date: 2016-02-11T15:04:23.193-06:00 Pause: 2.018
Date: 2016-02-11T15:04:23.193-06:00 Pause: 0.0
Date: 2016-02-11T15:04:23.231-06:00 Pause: 0.036
Date: 2016-02-11T15:04:23.231-06:00 Pause: 0.0
Date: 2016-02-11T15:04:28.254-06:00 Pause: 4.912
Date: 2016-02-11T15:04:29.004-06:00 Pause: 0.0
Date: 2016-02-11T15:04:34.463-06:00 Pause: 3.232
Date: 2016-02-11T15:04:34.463-06:00 Pause: 0.0
Date: 2016-02-11T15:04:34.491-06:00 Pause: 0.028
</code></pre>

<p>From this point, I can really pull together some good statistics on frequency,
rate of growth, high-activity, and create those smell tests that you wish you
knew before something blew up in your face.  In my work experience, it&rsquo;s not
often that people do enough testing with production-sized loads, or if they do,
they underestimate what those load look like.  It&rsquo;s the worst possible scenario
to have poor performance only in your production environment, as it is
a possible indicator that these kind of GC-related events were present in your
testing but were completely missed or avoided because they weren&rsquo;t visible.</p>

			</section>
		</article>
	</main>


	<footer role="contentinfo">
		<div class="hr"></div>
		<div class="footer-link">
			
			
			
			
		</div>
		<div class="copyright">Copyright &copy; 2016 Nick Klauer</div>
	</footer>

</div>



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>